\section{JEE}
Framework used to facilitate the development of Enterprise Application (EA).
Application based on JEE are portable everywhere there is Java EE.
JEE applications are based on the use of \emph{components} that communicate with each other.
Components are deployed inside \emph{containers}, which provide various services such as lifecycle management, lookup of other components and communication between components.

Multitiered architecture:
\begin{itemize}
    \item Client tier
    \item Web tier
    \item Business tier
    \item Enterprise Information System (EIS) tier
\end{itemize}

\subsection{Client Tier Containers}
\textbf{Applet container} to manage the execution of applets (web browser + Java plugin).

\textbf{Application client container} to manage the execution of application client components.

\subsection{Client Tier Components}
\textbf{Application client} is a component that runs directly on the machine.

\textbf{Applet} is a component that is integrated in a web page and executed through a plugin.

\textbf{Web clients} is a client made of dynamic web pages generated by web components (only browser needed).

\subsection{Web Tier Containers}
\textbf{Web container} is the interface between web components and the web server. Manages components lifecycle, dispatches requests to application components, provides information about current request.

\subsection{Web Tier Components}
\textbf{Servlets} is a component that extends the capabilities of a base server by using the request-response paradigm. Commonly used for HTTP requests. Acts as a middleware.

\textbf{JSP pages} text-based documents that embed JSP (Java) elements, that are dynamically constructed (dynamic content).

\textbf{JavaServer Pages} based on servlets and JSP, provides user interface component framework fro web applications.

\subsection{Business Tier Container}
\textbf{EJB container} provides a run-time environment for enterprise beans within the application. Middleware between business logic within the beans and the rest of the application server. Maintains pools of beans to improve performance and is a midddleware between beans and the underlying EIS.

\subsection{Business Tier Components}
\textbf{Enterprise Java Bean} is a server-side component that encapsulates the business logic of an application.
There are various types of beans:
\begin{itemize}
    \item Session beans
    \begin{itemize}
        \item Stateful session beans: one bean for each client, maintains state of the conversation.
        \item Stateless session beans: does not maintain any kind of state, all instances are equivalent.
        \item Singleton session beans: only one instance per application.
    \end{itemize}
    \item Message-driven beans: act as a JMS (Java Messaging System) message listener. These beans execute upon receiving a new message, stateless by design, all instances are equivalent.
\end{itemize}

\subsection{JNDI}
\emph{Java Naming and Directory Interface} enables components to locate other components and resources.
Each resource is identified by a unique identifier (JNDI name).

Generic lookup:
\begin{lstlisting}[language=Java]
DataSource ds = (DataSource) InitialContext
    .lookup("java:comp/DefaultDataSource");
\end{lstlisting}

\subsection{Resource Injection}
Another way to use JNDI names.
Injects JNDI resources directly, resolved by resource name and it is not type safe.
\begin{lstlisting}[language=Java]
public class MyServlet extends HttpServlet {
    @Resource(name="java:comp/DefaultDataSource")
    private javax.sql.DataSource dsc;
}
\end{lstlisting}

\subsection{Dependency Injection}
Java classes become managed objects.
Higher decoupling.
Injects regular classes, resolved by type, and it is type safe.
\begin{lstlisting}[language=Java]
public class Billing {
    @inject CurrencyConverter cc;
}
\end{lstlisting}

\subsection{Instance Pooling}
JEE maintains a pool of ready to use beans, in order to have better performance.
In case of stateless session beans or message-driven beans, every instance is the same (there is no state).
In this case beans can only have two states: \emph{ready} or \emph{non-existent}.

Lifecycle:
\begin{enumerate}
    \item Create bean.
    \item Dependency Injection.
    \item Invocation of \lstinline{@PostConstruct} method (if exists).
    The bean is now ready.
    \item When ready, the bean can accept various requests (or messages in case of message-driven beans).
    \item At the end of lifecycle, invocation of \lstinline{@PreDestroy} method (if exists).
    \item Bean is garbage-collected.
\end{enumerate}

In case of singleton beans, only one instance per application.
If singleton is annotated with \lstinline{@Startup}, it is instantiated upon application deployment.

\subsection{Activation/Passivation}
Used for stateful session beans.
Each bean, if not used, is serialized and written to disk (Passivation).
When a requests to that bean arrives, the bean is read from disk and recreated (Activation).

Lifecycle:
\begin{enumerate}
    \item Create bean.
    \item Dependency Injection.
    \item Invocation of \lstinline{@PostConstruct} method (if exists).
    The bean is now ready.
    \item When ready, the bean can accept various requests.
    \item For passivation, invocation to \lstinline{@PrePassivate}.
    \item For activation, invocation to \lstinline{@PostActivate}.
    \item At the end of lifecycle, invocation of \lstinline{@Remove}.
    \item Invocation of \lstinline{@PreDestroy} method (if exists).
    \item Bean is garbage-collected.
\end{enumerate}

\subsection{JPA}
\emph{Java Persistence API} is an interface to manage a DB (usually relational).

\subsubsection{Entity}
A table of the DB corresponds to a Java class.
The attributes of the Java class are mapped to columns of the table.
Relationships are define through annotations.

Example:
\begin{lstlisting}[language=Java]
@Entity
@Table(name="users")
public class User implements Serializable {
    @Id
    @GeneratedValue(strategy=GenerationType.AUTO)
    private Long Uid;

    @NotNull
    private String name;

    @Pattern(regexp="...")
    private String email;

    public User() {
        super();
    }

    // getter
    public Long getUid() {
        return Uid;
    }
}
\end{lstlisting}

\subsubsection{EntityManager}
Entities are managed by an \lstinline{EntityManager}, associated to a \emph{persistence context}.
\begin{itemize}
    \item Managing an Entity Instanceâ€™s Lifecycle
    \item Finding Entities Using the Entity Manager
    \item Persisting and Removing Entity Instances
    \item Query
    \item Synchronizing Entity Data to the Database
\end{itemize}

Example:
\begin{lstlisting}[language=Java]
@Stateless
public class MyProductManager implements ProdutManager {
    @PersistenceContext
    private EntityManager em;

    @Override
    public Product findProduct(int Productid) {
        return em.find(Product.class, Productid);
    }
}
\end{lstlisting}

\subsubsection{Named query}
Example:
\begin{lstlisting}[language=Java]
@Entity
@NamedQueries({
    @NamedQuery(
        name="Product.FIND_BY_NAME",
        query="SELECT p FROM Product PT WHERE PT.name=:name"
    )
})

// inside a business logic bean
@PersistenceContext
private EntityManager em;

@Override
public List<Product> findByName(String name) {
    Query query = em.createNamedQuery(
        "Product.FIND_BY_NAME",
        Product.class
    );
    query.setParameter("name", name);
    List<Product> p = query.getResultList();
    ...
}
\end{lstlisting}

\subsubsection{Relationship}
\textbf{Unidirectional One-to-one}\\
\begin{lstlisting}[language=Java]
@OneToOne
@JoinColumn(name="columnName")
private OtherEntity foo;
\end{lstlisting}

\textbf{Bidirectional One-to-one}\\
In the first entity entity:
\begin{lstlisting}[language=Java]
@OneToOne
@JoinColumn(name="columnName")
private OtherEntity foo;
\end{lstlisting}

In the other entity:
\begin{lstlisting}[language=Java]
@OneToOne(mappedBy=foo)
private FirstEntity bar;
\end{lstlisting}

\textbf{Many-to-one}\\
The primary key of the other entity is used as a foreign key.
\begin{lstlisting}[language=Java]
@ManyToOne
private OtherEntity foo;
\end{lstlisting}

\textbf{One-to-many}\\
\begin{lstlisting}[language=Java]
@OneToMany
private Collection<OtherEntity> foos;
\end{lstlisting}

\textbf{Bidirectional one-to-many/many-to-one}\\
In the first entity:
\begin{lstlisting}[language=Java]
@ManyToOne
private OtherEntity foo;
\end{lstlisting}

In the other entity:
\begin{lstlisting}[language=Java]
@OneToMany(mappedBy=foo)
private Collection<FirstEntity> bars;
\end{lstlisting}

\textbf{Unidirectional many-to-many}\\
Let's suppose to have two tables $A$ and $B$, $A$ having primary key $Aid$, $B$ having primary key $Bid$.
The join table is called $JT$ and has two columns $fkA$ and $fkB$, respectively the foreign key to $Aid$ and $Bid$.

Inside entity $A$ we have:
\begin{lstlisting}[language=Java]
@ManyToMany
@JoinTable(
    name="JT",
    joinColumns = {
        @JoinColumn(
            name="fkA",
            referencedColumnName="Aid"
        )
    },
    inverseJoinColumns ={
        @JoinColumn(
            name="fkB",
            referencedColumnName="Bid"
        )
    }
)
private Collection<B> foo;
\end{lstlisting}

\textbf{Bidirectional many-to-many}\\
In entity $A$ is the same as before, in entity $B$:
\begin{lstlisting}[language=Java]
@ManyToMany(mappedBy="foo")
private Collection<A> bar;
\end{lstlisting}